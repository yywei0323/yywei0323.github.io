<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://yywei0323.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://yywei0323.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-10-09T16:01:51+00:00</updated><id>https://yywei0323.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">【CISSP&amp;amp;CISP】- 学习资料</title><link href="https://yywei0323.github.io/blog/2024/security-cissp/" rel="alternate" type="text/html" title="【CISSP&amp;amp;CISP】- 学习资料"/><published>2024-09-20T16:10:16+00:00</published><updated>2024-09-20T16:10:16+00:00</updated><id>https://yywei0323.github.io/blog/2024/security-cissp</id><content type="html" xml:base="https://yywei0323.github.io/blog/2024/security-cissp/"><![CDATA[<h1 id="cisp">CISP</h1> <blockquote> <p>刷题平台:https://www.zaixiankaoshi.com/online/paper/detail/?paperid=3231392</p> </blockquote> <h1 id="cissp">CISSP</h1> <blockquote> <p><a href="https://blog.csdn.net/u013129300/article/details/134344328">不报辅导班一次性通过CISSP经验分享</a></p> </blockquote> <h2 id="复习流程">复习流程：</h2> <ul> <li>过三遍《CISSP官方学习指南（第8版）》</li> <li>模拟考试《CISSP官方习题册（第2版）》</li> </ul>]]></content><author><name></name></author><category term="Security"/><summary type="html"><![CDATA[CISP 刷题平台:https://www.zaixiankaoshi.com/online/paper/detail/?paperid=3231392]]></summary></entry><entry><title type="html">【CISSP】- 学习资料</title><link href="https://yywei0323.github.io/blog/2024/ctf_learning/" rel="alternate" type="text/html" title="【CISSP】- 学习资料"/><published>2024-09-20T16:10:16+00:00</published><updated>2024-09-20T16:10:16+00:00</updated><id>https://yywei0323.github.io/blog/2024/ctf_learning</id><content type="html" xml:base="https://yywei0323.github.io/blog/2024/ctf_learning/"><![CDATA[<blockquote> </blockquote>]]></content><author><name></name></author><category term="Security"/><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">逆波兰表达式、滑动窗口最大值、前 K 个高频元素</title><link href="https://yywei0323.github.io/blog/2023/algorithm_%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-Copy1/" rel="alternate" type="text/html" title="逆波兰表达式、滑动窗口最大值、前 K 个高频元素"/><published>2023-09-15T20:40:16+00:00</published><updated>2023-09-15T20:40:16+00:00</updated><id>https://yywei0323.github.io/blog/2023/algorithm_%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-Copy1</id><content type="html" xml:base="https://yywei0323.github.io/blog/2023/algorithm_%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-Copy1/"><![CDATA[<blockquote> <p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/">逆波兰表达式题目</a></p> <p><a href="https://programmercarl.com/0150.逆波兰表达式求值.html#其他语言版本">逆波兰表达式代码随想录</a></p> <p><a href="https://leetcode.cn/problems/sliding-window-maximum/">滑动窗口最大值</a></p> <p><a href="https://programmercarl.com/0239.滑动窗口最大值.html">滑动窗口最大值代码随想录</a></p> <p><a href="https://leetcode.cn/problems/top-k-frequent-elements/description/">前K个高频元素</a></p> <p><a href="https://programmercarl.com/0347.前K个高频元素.html">前K个高频元素代码随想录</a></p> </blockquote> <h2 id="150逆波兰表达式求值">150.逆波兰表达式求值</h2> <h3 id="题目">题目</h3> <p>给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。 请你计算该表达式。返回一个表示表达式值的整数。 注意： 有效的算符为 ‘+’、’-‘、’*’ 和 ‘/’ 。</p> <ul> <li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li> <li>两个整数之间的除法总是 向零截断 。</li> <li>表达式中不含除零运算。</li> <li>输入是一个根据逆波兰表示法表示的算术表达式。</li> <li>答案及所有中间计算结果可以用 32 位 整数表示。</li> </ul> <h2 id="题解方法">题解方法</h2> <ul> <li>采用两个队列模拟栈；</li> <li>在需要pop时，将in栈中所有元素弹出至out栈中，则out栈；</li> </ul> <h1 id="题解代码">题解代码</h1> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyQueue</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">stack_in</span> <span class="o">=</span> <span class="n">collections</span><span class="p">.</span><span class="n">deque</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">stack_out</span> <span class="o">=</span> <span class="n">collections</span><span class="p">.</span><span class="n">deque</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">stack_in</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">empty</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">stack_out</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">stack_out</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">stack_in</span><span class="p">)):</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">stack_in</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">stack_out</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">node_i</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">stack_out</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">node_i</span>


    <span class="k">def</span> <span class="nf">peek</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">node_1</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">stack_out</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node_1</span>

    <span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">stack_in</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">stack_out</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div> <h2 id="225用队列实现栈">225.用队列实现栈</h2> <h2 id="题目-1">题目</h2> <p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code class="language-plaintext highlighter-rouge">push</code>、<code class="language-plaintext highlighter-rouge">top</code>、<code class="language-plaintext highlighter-rouge">pop</code> 和 <code class="language-plaintext highlighter-rouge">empty</code>）。</p> <p>实现 <code class="language-plaintext highlighter-rouge">MyStack</code> 类：</p> <ul> <li><code class="language-plaintext highlighter-rouge">void push(int x)</code> 将元素 <code class="language-plaintext highlighter-rouge">x</code> 压入栈顶。</li> <li><code class="language-plaintext highlighter-rouge">int pop()</code> 移除并返回栈顶元素。</li> <li><code class="language-plaintext highlighter-rouge">int top()</code> 返回栈顶元素。</li> <li><code class="language-plaintext highlighter-rouge">boolean empty()</code> 如果栈是空的，返回 <code class="language-plaintext highlighter-rouge">true</code> ；否则，返回 <code class="language-plaintext highlighter-rouge">false</code> 。</li> </ul> <h2 id="题解">题解</h2> <ul> <li>拿队列的实现栈 问题也在pop和top</li> <li>每次pop时 将所有队列顶部数据重新弹出再放入一遍 保持队列顺序不变的情况下，重新来一遍；</li> </ul> <h2 id="题解代码-1">题解代码</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="k">class</span> <span class="nc">MyStack</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">empty</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">top</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">empty</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">node_i</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node_i</span>

    <span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="Algorithm"/><summary type="html"><![CDATA[代码随想录算法训练营第十一天]]></summary></entry><entry><title type="html">队列和栈基础知识：225用队列实现栈、用栈实现队列</title><link href="https://yywei0323.github.io/blog/2023/algorithm_%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="alternate" type="text/html" title="队列和栈基础知识：225用队列实现栈、用栈实现队列"/><published>2023-09-14T20:40:16+00:00</published><updated>2023-09-14T20:40:16+00:00</updated><id>https://yywei0323.github.io/blog/2023/algorithm_%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86</id><content type="html" xml:base="https://yywei0323.github.io/blog/2023/algorithm_%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><![CDATA[<blockquote> <p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232用栈实现队列</a></p> <p><a href="https://programmercarl.com/0232.用栈实现队列.html#其他语言版本">用栈实现队列代码随想录</a></p> <p><a href="https://leetcode.cn/problems/implement-stack-using-queues/description/">225用队列实现栈</a></p> <p><a href="https://programmercarl.com/0225.用队列实现栈.html#其他语言版本">用队列实现栈代码随想录</a></p> </blockquote> <h2 id="232用栈实现队列">232.用栈实现队列</h2> <h3 id="题目">题目</h3> <p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p> <p>实现 MyQueue 类：</p> <p><code class="language-plaintext highlighter-rouge">void push(int x)</code> 将元素 x 推到队列的末尾 <code class="language-plaintext highlighter-rouge">int pop()</code> 从队列的开头移除并返回元素 <code class="language-plaintext highlighter-rouge">int peek()</code> 返回队列开头的元素 <code class="language-plaintext highlighter-rouge">boolean empty()</code> 如果队列为空，返回 <code class="language-plaintext highlighter-rouge">true</code> ；否则，返回 <code class="language-plaintext highlighter-rouge">false</code> 说明：</p> <p>你 只能 使用标准的栈操作 —— 也就是只有 <code class="language-plaintext highlighter-rouge">push to top</code>, <code class="language-plaintext highlighter-rouge">peek/pop from top</code>, <code class="language-plaintext highlighter-rouge">size</code>, 和 <code class="language-plaintext highlighter-rouge">is empty</code> 操作是合法的。 你所使用的语言也许不支持栈。你可以使用 <code class="language-plaintext highlighter-rouge">list</code> 或者 <code class="language-plaintext highlighter-rouge">deque</code>（双端队列）来模拟一个栈，只要是标准的栈操作即可。</p> <h2 id="题解方法">题解方法</h2> <ul> <li>采用两个队列模拟栈；</li> <li>在需要pop时，将in栈中所有元素弹出至out栈中，则out栈；</li> </ul> <h1 id="题解代码">题解代码</h1> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyQueue</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">stack_in</span> <span class="o">=</span> <span class="n">collections</span><span class="p">.</span><span class="n">deque</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">stack_out</span> <span class="o">=</span> <span class="n">collections</span><span class="p">.</span><span class="n">deque</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">stack_in</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">empty</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">stack_out</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">stack_out</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">stack_in</span><span class="p">)):</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">stack_in</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">stack_out</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">node_i</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">stack_out</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">node_i</span>


    <span class="k">def</span> <span class="nf">peek</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">node_1</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">stack_out</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node_1</span>

    <span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">stack_in</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">stack_out</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div> <h2 id="225用队列实现栈">225.用队列实现栈</h2> <h2 id="题目-1">题目</h2> <p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code class="language-plaintext highlighter-rouge">push</code>、<code class="language-plaintext highlighter-rouge">top</code>、<code class="language-plaintext highlighter-rouge">pop</code> 和 <code class="language-plaintext highlighter-rouge">empty</code>）。</p> <p>实现 <code class="language-plaintext highlighter-rouge">MyStack</code> 类：</p> <ul> <li><code class="language-plaintext highlighter-rouge">void push(int x)</code> 将元素 <code class="language-plaintext highlighter-rouge">x</code> 压入栈顶。</li> <li><code class="language-plaintext highlighter-rouge">int pop()</code> 移除并返回栈顶元素。</li> <li><code class="language-plaintext highlighter-rouge">int top()</code> 返回栈顶元素。</li> <li><code class="language-plaintext highlighter-rouge">boolean empty()</code> 如果栈是空的，返回 <code class="language-plaintext highlighter-rouge">true</code> ；否则，返回 <code class="language-plaintext highlighter-rouge">false</code> 。</li> </ul> <h2 id="题解">题解</h2> <ul> <li>拿队列的实现栈 问题也在pop和top</li> <li>每次pop时 将所有队列顶部数据重新弹出再放入一遍 保持队列顺序不变的情况下，重新来一遍；</li> </ul> <h2 id="题解代码-1">题解代码</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="k">class</span> <span class="nc">MyStack</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">empty</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">top</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">empty</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">node_i</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node_i</span>

    <span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="Algorithm"/><summary type="html"><![CDATA[代码随想录算法训练营第十天]]></summary></entry><entry><title type="html">KMP算法-28字符串匹配+重复字符串</title><link href="https://yywei0323.github.io/blog/2023/algorithm_KMP%E7%AE%97%E6%B3%95-28%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="alternate" type="text/html" title="KMP算法-28字符串匹配+重复字符串"/><published>2023-09-13T20:40:16+00:00</published><updated>2023-09-13T20:40:16+00:00</updated><id>https://yywei0323.github.io/blog/2023/algorithm_KMP%E7%AE%97%E6%B3%95-28%E5%AD%97%E7%AC%A6%E4%B8%B2</id><content type="html" xml:base="https://yywei0323.github.io/blog/2023/algorithm_KMP%E7%AE%97%E6%B3%95-28%E5%AD%97%E7%AC%A6%E4%B8%B2/"><![CDATA[<blockquote> <p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">28.strStr()</a></p> <p><a href="https://programmercarl.com/0028.实现strStr.html#思路">实现strStr()代码随想录</a></p> <p><a href="https://leetcode.cn/problems/repeated-substring-pattern/submissions/538631105/">459.重复字符串</a></p> <p><a href="https://programmercarl.com/0459.重复的子字符串.html#其他语言版本">重复字符串代码随想录</a></p> </blockquote> <h2 id="28字符串匹配">28.字符串匹配</h2> <h3 id="题目">题目</h3> <p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1 。</p> <h2 id="题解方法kmp">题解方法——KMP</h2> <ul> <li>next数组：最大相同前后缀数组 next[i]代表needle第i个字符的最大相同前后缀</li> <li>获取next数组： <ul> <li>判断当前字符串是否有重合</li> <li>如果没有回退到上一个字符的最大相同前后缀处</li> </ul> </li> </ul> <h1 id="题解代码">题解代码</h1> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">getnext</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="p">):</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">next_</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
            <span class="k">while</span> <span class="n">j</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">!=</span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span><span class="c1">##不一样 且不是初始值 则回退到上一个点
</span>                <span class="n">j</span> <span class="o">=</span> <span class="n">next_</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">j</span> <span class="o">+=</span><span class="mi">1</span>
            <span class="n">next_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
        <span class="k">return</span> <span class="n">next_</span>

    <span class="k">def</span> <span class="nf">strStr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">haystack</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">needle</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">needle</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">next_</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">getnext</span><span class="p">(</span><span class="n">needle</span><span class="p">)</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">haystack</span><span class="p">)):</span>
            <span class="k">while</span> <span class="n">j</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">!=</span><span class="n">needle</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">next_</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">needle</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">j</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">j</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">needle</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">i</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">needle</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div></div> <h2 id="459重复字符串">459.重复字符串</h2> <h2 id="题目-1">题目</h2> <p>给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成</p> <h2 id="题解">题解</h2> <ul> <li>方案1:移动匹配法：如果由重复字符串组成<code class="language-plaintext highlighter-rouge">s[1:]+s[-1]=s</code>成立；</li> <li>方案2 <ul> <li>计算next_数组；如果最大相同前后缀 相差值 能%==0 说明刚好差一个原子值；</li> </ul> </li> </ul> <h2 id="题解代码-1">题解代码</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
        <span class="k">if</span> <span class="s">"a"</span><span class="o">&lt;=</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="s">"z"</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s">"number"</span>
    <span class="k">print</span><span class="p">(</span><span class="s">""</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Algorithm"/><summary type="html"><![CDATA[代码随想录算法训练营第九天]]></summary></entry><entry><title type="html">字符串：344反转字符串、541反转字符串2、替换数字、翻转字符串内单词、55右旋转字符串</title><link href="https://yywei0323.github.io/blog/2023/algorithm_%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%93%E9%A2%98-344+541+55/" rel="alternate" type="text/html" title="字符串：344反转字符串、541反转字符串2、替换数字、翻转字符串内单词、55右旋转字符串"/><published>2023-09-12T20:40:16+00:00</published><updated>2023-09-12T20:40:16+00:00</updated><id>https://yywei0323.github.io/blog/2023/algorithm_%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%93%E9%A2%98-344+541+55</id><content type="html" xml:base="https://yywei0323.github.io/blog/2023/algorithm_%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%93%E9%A2%98-344+541+55/"><![CDATA[<blockquote> <p><a href="https://leetcode.cn/problems/reverse-string/">反转字符串</a></p> <p><a href="https://programmercarl.com/0344.反转字符串.html#算法公开课">反转字符串代码随想录</a></p> <p><a href="https://kamacoder.com/problempage.php?pid=1064">替换数字</a></p> <p><a href="https://programmercarl.com/kama54.替换数字.html#其他语言版本">替换数字代码随想录</a></p> <p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/description/">翻转单词</a></p> <p><a href="https://kamacoder.com/problempage.php?pid=1065">右旋字符串</a></p> </blockquote> <h1 id="344反转字符串">344反转字符串</h1> <h2 id="题目">题目</h2> <p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</p> <p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p> <h2 id="题解">题解</h2> <ul> <li>现有方法： <ul> <li>双指针：左右互换；</li> <li>遍历：循环前一半</li> <li>函数：reversed函数</li> <li>递推</li> </ul> </li> </ul> <h1 id="题解代码">题解代码</h1> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">reverseString</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="s">"""
        Do not return anything, modify s in-place instead.
        """</span>
        <span class="n">l</span><span class="p">,</span><span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">while</span> <span class="n">l</span><span class="o">&lt;</span><span class="n">r</span><span class="p">:</span>
            <span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="p">],</span><span class="n">s</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">r</span><span class="p">],</span><span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>
            <span class="n">l</span><span class="o">+=</span><span class="mi">1</span>
            <span class="n">r</span><span class="o">-=</span><span class="mi">1</span>
</code></pre></div></div> <h1 id="替换数字">替换数字</h1> <h2 id="题目-1">题目</h2> <p>给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。 例如，对于输入字符串 “a1b2c3”，函数应该将其转换为 “anumberbnumbercnumber”。</p> <h2 id="题解-1">题解</h2> <ul> <li>字符串不能直接在原位修改转为列表</li> <li>字符串本身可以比大小</li> </ul> <h2 id="题解代码-1">题解代码</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
        <span class="k">if</span> <span class="s">"a"</span><span class="o">&lt;=</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="s">"z"</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s">"number"</span>
    <span class="k">print</span><span class="p">(</span><span class="s">""</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</code></pre></div></div> <h1 id="55右旋转字符串">55.右旋转字符串</h1> <h2 id="题目-2">题目</h2> <p>字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。</p> <p>例如，对于输入字符串 “abcdefg” 和整数 2，函数应该将其转换为 “fgabcde”。</p> <h2 id="题解-2">题解：</h2> <ul> <li>思路1：直接重新拼接字符串 从<code class="language-plaintext highlighter-rouge">k%len</code>划分开拼接；</li> <li>思路2：反转两次=没有反转-&gt; 整体反向+前后分别反向</li> </ul> <h2 id="题解代码-2">题解代码</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">num</span> <span class="o">=</span> <span class="nb">input</span><span class="p">()</span>
<span class="n">str_</span> <span class="o">=</span> <span class="nb">input</span><span class="p">()</span>
<span class="n">num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">righerreverse</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="n">str_</span><span class="p">):</span>
    <span class="n">str_</span> <span class="o">=</span> <span class="n">str_</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">res_str</span> <span class="o">=</span> <span class="n">str_</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">num</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">str_</span><span class="p">[</span><span class="n">num</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">res_str</span>

<span class="n">res_str</span> <span class="o">=</span> <span class="n">righerreverse</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="n">str_</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">res_str</span><span class="p">)</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
        <span class="k">if</span> <span class="s">"a"</span><span class="o">&lt;=</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="s">"z"</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s">"number"</span>
    <span class="k">print</span><span class="p">(</span><span class="s">""</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</code></pre></div></div> <h1 id="55右旋转字符串-1">55.右旋转字符串</h1> <h2 id="题目-3">题目</h2> <p>字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。</p> <p>例如，对于输入字符串 “abcdefg” 和整数 2，函数应该将其转换为 “fgabcde”。</p> <h2 id="题解-3">题解：</h2> <ul> <li>思路1：直接重新拼接字符串 从<code class="language-plaintext highlighter-rouge">k%len</code>划分开拼接；</li> <li>思路2：反转两次=没有反转-&gt; 整体反向+前后分别反向</li> </ul> <h2 id="题解代码-3">题解代码</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">num</span> <span class="o">=</span> <span class="nb">input</span><span class="p">()</span>
<span class="n">str_</span> <span class="o">=</span> <span class="nb">input</span><span class="p">()</span>
<span class="n">num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">righerreverse</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="n">str_</span><span class="p">):</span>
    <span class="n">str_</span> <span class="o">=</span> <span class="n">str_</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">res_str</span> <span class="o">=</span> <span class="n">str_</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">num</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">str_</span><span class="p">[</span><span class="n">num</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">res_str</span>

<span class="n">res_str</span> <span class="o">=</span> <span class="n">righerreverse</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="n">str_</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">res_str</span><span class="p">)</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
        <span class="k">if</span> <span class="s">"a"</span><span class="o">&lt;=</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="s">"z"</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s">"number"</span>
    <span class="k">print</span><span class="p">(</span><span class="s">""</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Algorithm"/><summary type="html"><![CDATA[代码随想录算法训练营第八天]]></summary></entry><entry><title type="html">383赎金信、N数之和</title><link href="https://yywei0323.github.io/blog/2023/algorithm_383+454+015+018/" rel="alternate" type="text/html" title="383赎金信、N数之和"/><published>2023-09-11T20:40:16+00:00</published><updated>2023-09-11T20:40:16+00:00</updated><id>https://yywei0323.github.io/blog/2023/algorithm_383+454+015+018</id><content type="html" xml:base="https://yywei0323.github.io/blog/2023/algorithm_383+454+015+018/"><![CDATA[<blockquote> <p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">383赎金信</a></p> <p><a href="https://programmercarl.com/0383.赎金信.html#思路">383赎金信代码随想录</a></p> <p><a href="https://leetcode.cn/problems/4sum-ii/">454四数之和2</a></p> <p><a href="https://programmercarl.com/0454.四数相加II.html#算法公开课">454四数之和2代码随想录</a></p> <p><a href="https://leetcode.cn/problems/3sum/description/">015三数之和</a></p> <p><a href="https://programmercarl.com/0015.三数之和.html#思路">015三数之和代码随想录</a></p> <p><a href="https://leetcode.cn/problems/4sum/description/">018四数之和</a></p> <p><a href="https://programmercarl.com/0018.四数之和.html#算法公开课">018四数之和代码随想录</a></p> </blockquote> <h1 id="383赎金信">383赎金信</h1> <h2 id="题目">题目</h2> <p>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。</p> <p>如果可以，返回 true ；否则返回 false 。</p> <p>magazine 中的每个字符只能在 ransomNote 中使用一次。</p> <h2 id="题解">题解</h2> <p>和前面计数一样</p> <h1 id="四数之和2">四数之和2</h1> <h2 id="题目-1">题目</h2> <p>给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：</p> <ul> <li>0 &lt;= i, j, k, l &lt; n</li> <li>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</li> </ul> <h2 id="题解-1">题解</h2> <ul> <li>不要求题解中不出现重复数字</li> <li>从不同数组中挑数字 不需要考虑重复问题</li> <li>更简单</li> <li>1个哈希表 分别对2组数组计算即可</li> </ul> <h2 id="题解代码">题解代码</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">fourSumCount</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums1</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">nums2</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">nums3</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">nums4</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">hash_table</span> <span class="o">=</span><span class="p">{}</span>
        <span class="k">for</span> <span class="n">num_1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums1</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">num_2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">)):</span>
                <span class="n">num</span> <span class="o">=</span> <span class="n">nums1</span><span class="p">[</span><span class="n">num_1</span><span class="p">]</span><span class="o">+</span><span class="n">nums2</span><span class="p">[</span><span class="n">num_2</span><span class="p">]</span>
                <span class="n">hash_table</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="n">hash_table</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>

        <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">num_3</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums3</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">num_4</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums4</span><span class="p">)):</span>
                <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="o">-</span><span class="p">(</span><span class="n">nums3</span><span class="p">[</span><span class="n">num_3</span><span class="p">]</span><span class="o">+</span><span class="n">nums4</span><span class="p">[</span><span class="n">num_4</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">hash_table</span><span class="p">:</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">+</span> <span class="n">hash_table</span><span class="p">[</span><span class="n">num</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div> <h1 id="三数之和--四数之和">三数之和 + 四数之和</h1> <h2 id="三数之和题目">三数之和题目</h2> <p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请</p> <p>你返回所有和为 0 且不重复的三元组。</p> <p>注意：答案中不可以包含重复的三元组。</p> <h2 id="四数之和题目">四数之和题目</h2> <p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</p> <p>0 &lt;= a, b, c, d &lt; n a、b、c 和 d 互不相同 nums[a] + nums[b] + nums[c] + nums[d] == target 你可以按 任意顺序 返回答案 。</p> <h2 id="题解同类">题解（同类）：</h2> <ul> <li>首先排序</li> <li>固定指针，剩下由双指针计算两数之和；</li> <li>一开始使用二分法 这里不能用二分法 因为不确定一定存在；</li> <li>注意剪枝 <ul> <li>个数剪枝：不满足个数 直接返回</li> <li>遍历函数剪枝（target不确定时，需要确定数字正负）：超过target返回-&gt;因为是按大小排序的</li> <li>指针剪枝：和前面相同直接跳过</li> </ul> </li> </ul> <h2 id="题解代码-1">题解代码</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">fourSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="c1">##首先排除无结果的输入
</span>        <span class="n">nums</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1">##初始化
</span>        <span class="c1">##第一个遍历循环
</span>        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="n">target</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">res</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="c1">##第二个遍历循环
</span>            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&gt;</span><span class="n">target</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">if</span> <span class="n">j</span><span class="o">&gt;</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">==</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">continue</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span>
                <span class="c1">##指针寻找target
</span>                <span class="k">while</span> <span class="n">l</span><span class="o">&lt;</span><span class="n">r</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">&lt;</span><span class="n">target</span><span class="p">:</span>
                        <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">+</span><span class="mi">1</span>
                    <span class="k">elif</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">&gt;</span><span class="n">target</span><span class="p">:</span>
                        <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="o">-</span><span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">nums</span><span class="p">[</span><span class="n">l</span><span class="p">],</span><span class="n">nums</span><span class="p">[</span><span class="n">r</span><span class="p">]])</span>
                        <span class="k">while</span> <span class="mi">0</span><span class="o">&lt;</span><span class="n">l</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">nums</span><span class="p">[</span><span class="n">l</span><span class="p">]:</span>
                            <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">+</span><span class="mi">1</span>
                        <span class="k">while</span> <span class="n">l</span><span class="o">&lt;</span><span class="n">r</span><span class="o">&lt;</span><span class="n">n</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">nums</span><span class="p">[</span><span class="n">r</span><span class="p">]:</span>
                            <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="o">-</span><span class="mi">1</span>
                        <span class="c1">##2个指针固定以后，可能有n个答案
</span>                        <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">+</span><span class="mi">1</span>
                        <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Algorithm"/><summary type="html"><![CDATA[代码随想录算法训练营第七天]]></summary></entry><entry><title type="html">RAG</title><link href="https://yywei0323.github.io/blog/2023/aI_algorithm/" rel="alternate" type="text/html" title="RAG"/><published>2023-09-11T20:40:16+00:00</published><updated>2023-09-11T20:40:16+00:00</updated><id>https://yywei0323.github.io/blog/2023/aI_algorithm</id><content type="html" xml:base="https://yywei0323.github.io/blog/2023/aI_algorithm/"><![CDATA[<h1 id="how-to-cooperate-with-llm-">How to cooperate with LLM? 🤔</h1> <ol> <li> <p>相关技术</p> <ul> <li><strong>RAG</strong>:结合信息检索与模型生成的方法。通过检索相关文档来辅助生成答案或内容。<strong>从外部知识库中检索信息、结合大模型生成更精准的答案。</strong></li> <li><strong>Prompt Engineering</strong>:给模型提供一个合适的输入提示，模型根据<strong>该提示生成相应的输出。</strong>通过设计不同的 Prompt，可以显著影响大模型的行为。</li> <li><strong>Fine-Tuning</strong>:在已有的大模型基础上进行再训练，使其适应特定的任务。<strong>在小规模的数据集上进行微调</strong>，而不需要重新训练整个模型。</li> <li>Zero-shot &amp; Few-shot Learning:模型不需要针对新任务的数据进行训练就可以完成任务，Few-shot 则是在非常少的数据样本上进行训练。</li> <li>Distillation（模型蒸馏）:通过将大型模型的知识压缩到较小模型中，从而保持性能但减少计算成本和模型大小</li> <li>Active Learning:智能地选择数据进行标注的技术，模型会主动选择不确定的数据来减少标注成本。</li> <li>Transfer Learning:将大模型在某个领域学习到的知识转移到另一个领域，减少新任务所需的数据和计算量。</li> </ul> </li> <li> <p>相关框架</p> </li> </ol> <table id="table" data-toggle="table" data-url="/assets/json/rag_data/table_1.json"> <thead> <tr> <th data-field="name">Name</th> <th data-field="technology">Technology</th> <th data-field="description">Description</th> <th data-field="link">Link</th> </tr> </thead> </table> <h1 id="whats-rag--">What’s RAG &amp; ?</h1>]]></content><author><name></name></author><category term="AI"/><summary type="html"><![CDATA[How to use LLM and What's RAG?]]></summary></entry><entry><title type="html">【Haystack 1】- Installation</title><link href="https://yywei0323.github.io/blog/2023/aI_haystack-1/" rel="alternate" type="text/html" title="【Haystack 1】- Installation"/><published>2023-09-11T20:40:16+00:00</published><updated>2023-09-11T20:40:16+00:00</updated><id>https://yywei0323.github.io/blog/2023/aI_haystack-1</id><content type="html" xml:base="https://yywei0323.github.io/blog/2023/aI_haystack-1/"><![CDATA[<p>Hello world! :smile:</p> <h1 id="how-to-cooperate-with-llm">How to cooperate with LLM?</h1> <ol> <li>相关技术 <ul> <li><strong>RAG</strong>:结合信息检索与模型生成的方法。通过检索相关文档来辅助生成答案或内容。<strong>从外部知识库中检索信息、结合大模型生成更精准的答案。</strong></li> <li><strong>Prompt Engineering</strong>:给模型提供一个合适的输入提示，模型根据<strong>该提示生成相应的输出。</strong>通过设计不同的 Prompt，可以显著影响大模型的行为。</li> <li><strong>Fine-Tuning</strong>:在已有的大模型基础上进行再训练，使其适应特定的任务。<strong>在小规模的数据集上进行微调</strong>，而不需要重新训练整个模型。</li> <li>Zero-shot &amp; Few-shot Learning:模型不需要针对新任务的数据进行训练就可以完成任务，Few-shot 则是在非常少的数据样本上进行训练。</li> <li>Distillation（模型蒸馏）:通过将大型模型的知识压缩到较小模型中，从而保持性能但减少计算成本和模型大小</li> <li>Active Learning:智能地选择数据进行标注的技术，模型会主动选择不确定的数据来减少标注成本。</li> <li>Transfer Learning:将大模型在某个领域学习到的知识转移到另一个领域，减少新任务所需的数据和计算量。</li> </ul> </li> <li>相关框架</li> </ol> <table id="table" data-toggle="table" data-url="/assets/json/rag_data/table_1.json"> <thead> <tr> <th data-field="name">Name</th> <th data-field="technology">Technology</th> <th data-field="description">Description</th> <th data-field="link">Link</th> </tr> </thead> </table> <h1 id="whats-rag--">What’s RAG &amp; ?</h1>]]></content><author><name></name></author><category term="AI"/><summary type="html"><![CDATA[Hello world! :smile:]]></summary></entry><entry><title type="html">哈希表基础;242有效字母异位;349两个数组交集;202快乐数</title><link href="https://yywei0323.github.io/blog/2023/algorithm_242+349+202/" rel="alternate" type="text/html" title="哈希表基础;242有效字母异位;349两个数组交集;202快乐数"/><published>2023-09-10T20:40:16+00:00</published><updated>2023-09-10T20:40:16+00:00</updated><id>https://yywei0323.github.io/blog/2023/algorithm_242+349+202</id><content type="html" xml:base="https://yywei0323.github.io/blog/2023/algorithm_242+349+202/"><![CDATA[<blockquote> <p><a href="https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%93%88%E5%B8%8C%E8%A1%A8">哈希表基础理论</a> <a href="https://leetcode.cn/problems/valid-anagram/description/">242有效字母异位词题</a></p> <p><a href="https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">242代码随想录解析</a></p> <p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349两个数组的交集</a></p> <p>[349代码随想录解析] (https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)</p> <p><a href="https://leetcode.cn/problems/happy-number/">202快乐数</a></p> <p><a href="https://programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">202代码随想录解析</a></p> </blockquote> <h1 id="哈希表基础理论">哈希表基础理论</h1> <p><strong><em>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</em></strong></p> <p>python中重要和字典相关的语句</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">num</span> <span class="o">=</span> <span class="n">res</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
<span class="c1">##res.get(num,0) 如果存在num，则获取该数值，如果不存在该key，则赋值为0
</span></code></pre></div></div> <h1 id="242有效字母异位词">242有效字母异位词</h1> <h2 id="题目">题目</h2> <p><strong>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</strong></p> <h2 id="题解">题解</h2> <p><strong>对于Python来说 有两种解决方案</strong></p> <ol> <li>直接采用python的collections.counter</li> <li>采用哈希表 统计26字母的频次</li> </ol> <h2 id="解法代码">解法代码</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">###解法一：counter
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isAnagram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">s_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">collections</span><span class="p">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
        <span class="n">t_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">collections</span><span class="p">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">s_dict</span><span class="o">==</span><span class="n">t_dict</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">##解法二
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isAnagram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">record</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">26</span> <span class="c1">##哈希表
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="n">record</span><span class="p">[</span><span class="nb">ord</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-</span><span class="nb">ord</span><span class="p">(</span><span class="s">"a"</span><span class="p">)]</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
            <span class="n">record</span><span class="p">[</span><span class="nb">ord</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-</span><span class="nb">ord</span><span class="p">(</span><span class="s">"a"</span><span class="p">)]</span><span class="o">-=</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">record</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div> <h1 id="349两个数组的交集">349两个数组的交集</h1> <h2 id="题目-1">题目</h2> <p><strong>给定两个数组 nums1 和 nums2 ，返回 它们的 交集。 输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。</strong></p> <h2 id="题解-1">题解：</h2> <ol> <li>采用字典和集合统计</li> <li>直接使用集合</li> </ol> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">##用集合方法
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums1</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">nums2</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">nums2</span><span class="p">))</span>
</code></pre></div></div> <h2 id="202快乐数">202快乐数</h2> <h3 id="题目-2">题目</h3> <p>**编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」 定义为： - 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。 - 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。 - 如果这个过程 结果为 1，那么这个数就是快乐数。 - 如果 n 是 快乐数 就返回 true ；不是，则返回 false。 **</p> <h2 id="题解-2">题解</h2> <p>要点在<strong>如果不是快乐数，可能无限循环始终变不到1</strong> 因此，只需要判断结果是否有重复出现即可</p> <h2 id="解题代码">解题代码</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isHappy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">n</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">while</span> <span class="n">curr</span><span class="o">!=</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">res</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">curr</span><span class="p">):</span>
                <span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">num</span>
            <span class="n">res</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">curr</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Algorithm"/><summary type="html"><![CDATA[代码随想录算法训练营第六天]]></summary></entry></feed>